import { NAME_FILES_DATA_ALLOWED } from '../constants/constant';

/**
 * Maps CSV filenames to database tables and provides column information
 */
class TableMapperService {
  validTables;
  tableColumns;

  constructor() {
    // Map of valid table names
    this.validTables = new Set(NAME_FILES_DATA_ALLOWED);

    // Cache for table column information
    this.tableColumns = {};
  }

  /**
   * Get table name from filename
   * @param {string} filename - Original filename
   * @returns {string|null} - Matching table name or null if no match
   */
  getTableNameFromFilename(filename) {
    // Remove file extension
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');

    // Check for exact matches first
    if (this.validTables.has(nameWithoutExt)) {
      return nameWithoutExt;
    }

    // Check for case-insensitive matches
    const lowerName = nameWithoutExt.toLowerCase();
    for (const tableName of this.validTables) {
      if (tableName.toLowerCase() === lowerName) {
        return tableName;
      }
    }

    // Check for partial matches (removing special characters)
    const cleanName = nameWithoutExt.replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();
    for (const tableName of this.validTables) {
      const cleanTableName = tableName.replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();
      if (cleanName === cleanTableName) {
        return tableName;
      }
    }

    // No match found
    return null;
  }

  /**
   * Check if a table exists in our valid tables list
   * @param {string} tableName - Table name to check
   * @returns {boolean} - Whether the table is valid
   */
  isValidTable(tableName) {
    return this.validTables.has(tableName);
  }

  /**
   * Get column information for a table from the database
   * @param {Object} db - Database connection
   * @param {string} tableName - Table name
   * @returns {Promise<Array>} - Array of column information
   */
  async getTableColumns(db, tableName) {
    // Return from cache if available
    if (this.tableColumns[tableName]) {
      return this.tableColumns[tableName];
    }

    // Query database for column information
    const query = `
        SELECT column_name, data_type, is_nullable
        FROM information_schema.columns
        WHERE table_schema = 'public'
          AND table_name = $1
        ORDER BY ordinal_position
    `;

    const { rows } = await db.query(query, [tableName]);

    // Cache the result
    this.tableColumns[tableName] = rows;

    return rows;
  }

  /**
   * Get set of columns that should be excluded from inserts
   * @returns {Set<string>} - Set of column names
   */
  getAutoGeneratedColumns() {
    return new Set([
      'id',                 // Auto-increment primary keys
      'created_at',         // Timestamps with defaults
      'updated_at',          // Timestamps with defaults
    ]);
  }

  /**
   * Convert CSV column headers to match database column format
   * @param {string} header - CSV column header
   * @returns {string} - Normalized column name
   */
  normalizeColumnName(header) {
    // Remove quotes if present
    let normalized = header.trim().replace(/^["']|["']$/g, '');

    // Convert to snake_case if camelCase
    normalized = normalized.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();

    // Replace spaces with underscores
    normalized = normalized.replace(/\s+/g, '_');

    // Remove special characters
    normalized = normalized.replace(/[^a-z0-9_]/g, '');

    return normalized;
  }

  /**
   * Format value based on PostgreSQL data type
   * @param {any} value - Value to format
   * @param {string} dataType - PostgreSQL data type
   * @returns {any} - Formatted value
   */
  formatValueForType(value, dataType) {
    // Handle null values
    if (value === null || value === undefined || value === '') {
      return null;
    }

    // Format based on data type
    switch (dataType.toLowerCase()) {
      case 'integer':
      case 'smallint':
      case 'bigint':
        return parseInt(value, 10);

      case 'numeric':
      case 'decimal':
      case 'real':
      case 'double precision':
        return parseFloat(value);

      case 'boolean':
        if (typeof value === 'string') {
          const lowerValue = value.toLowerCase();
          if (lowerValue === 'true' || lowerValue === 't' || lowerValue === 'yes' || lowerValue === 'y' || lowerValue === '1') {
            return true;
          }
          if (lowerValue === 'false' || lowerValue === 'f' || lowerValue === 'no' || lowerValue === 'n' || lowerValue === '0') {
            return false;
          }
        }
        return Boolean(value);

      case 'json':
      case 'jsonb':
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value; // Keep as string if can't parse
          }
        }
        return value;

      case 'date':
      case 'timestamp':
      case 'timestamp with time zone':
      case 'timestamp without time zone':
        if (value && value !== '0000-00-00') {
          return new Date(value);
        }
        return null;

      default:
        return value.toString();
    }
  }
}

module.exports = new TableMapperService();